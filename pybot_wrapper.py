"""
The main idea is wrapping :cmd:`pybot` to full control origin user behavior.

1.  RQ job:
    RQ jobs are stored in Redis for debug only.

    Of course, executing :cmd:`rq worker` is required.

2.  Function:
    return value is :cmd:`pybot` return code for debug only.

3.  Subprocess:

    A.  Its stdout/stderror are redirected into database for fetching later.
    B.  PID is stored for later control.
    C.  Stop a running :cmd:`pybot` by specifying the PID and
        sending `os.kill(pid, signal.SIGINT)` directly.
    D.  Collect test report generated by :cmd:`pybot` into database.

    Of course, it has to set/cleanup working directory for process.
"""

import os, signal

cmd = 'pybot mytest.robot'
save_db = print
stop_pybot = lambda pid: os.kill(pid, signal.SIGINT)
collect_test_report = lambda: None

def f():
    from time import sleep
    from subprocess import Popen, PIPE, STDOUT

    proc = Popen(f'{cmd}', shell=True, stdout=PIPE, stderr=STDOUT)
    save_db(f'proc obj: {proc}')
    save_db(f'proc pid: {proc.pid}')

    for line in proc.stdout:
        save_db(line)

    outs, errs = proc.communicate()
    assert outs == b''
    assert errs is None
    assert proc.returncode is not None

    collect_test_report()

    return proc.returncode  # refer to `pybot` for return code meaning
